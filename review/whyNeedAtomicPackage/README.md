
[如果对齐的内存写入是原子的，为什么还需要 sync/atomic 包](https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package)

现在的系统中，write 的地址基本都是对齐的（aligned）。如，32 位操作系统、CPU、编译器，write 的地址总是 4 的倍数，64 位系统总是 8 的倍数。

对齐地址的写，不会导致其他人看到只写了一半的数据，因为它通过一个指令就可以实现对地址的操作。

不对齐地址的写，则处理器就需要分成两个指令去进行处理。如果执行了一个指令，其他人就会看到更新了一半的错误的数据，这被称为**撕裂写（torn write）**。

但是，对于现代的多处理器多核的系统而言，一个核对地址的值的更改，在更新到主内存中前，是存放在多级缓存里的。这时，多个核看到的数据可能时不一样的，其它核可能还没看到更新的数据，还在使用旧的数据。

多处理器多核系统为了处理这类问题，使用一种叫做**内存屏障**（memory fence 或 memory barrier）的方式。

一个写内存屏障会告诉处理器，必须等它管道中未完成的操作（尤其是写操作）都被刷新到内存中，再进行操作。此操作还会让相关的处理器的 CPU 缓存失效，以便让它们从主存中拉去最新的值。

atomic 包提供的方法会提供内存屏障的功能，所以 atomic 不仅可以保证赋值的数据完整性，还能保证数据的可见性。一旦某个核更新了某个地址的值，其它处理器总能读取到它的最新值。

注：因为需要处理器间保证数据的一致性，atomic 的操作也会降低性能的。

