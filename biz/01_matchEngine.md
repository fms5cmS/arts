一个完整的交易流程：

1. 用户提交某个交易标的的买卖委托单；
2. 系统验证委托单是否有效（交易标的是否处于可交易的状态、订单的价格和数量是否符合要求等）；
3. 确定该委托单的[挂/吃单](./words_exchange.md#makertaker)费率；
4. 检查用户资产账户情况（账户状态是否交易受限、资金是否足够等）；
5. 将详细的委托单数据持久化到数据库，并冻结用户账户中相应数量的资金；
6. 将委托单进行撮合处理，即在[订单薄](./words_exchange.md#订单薄)中寻找能和该委托单匹配成交的订单；
7. 将撮合产生的成交记录持久化到数据库，并根据历史成交记录生成市场数据，如[K线](./words_exchange.md#k-线图)数据、今日涨跌幅等；
8. 更新数据库中所有成交订单的委托单数据，以及更新订单用户的资产账户余额；
9. 将更新的订单数据、市场数据等发送给到前台

订单撮合匹配的结果可能有多种：全部成交、部分成交或无匹配。

- 全部成交或部分成交时，可能在交易委托账本中存在一个或多个匹配的订单，即会产生一条或多条成交记录。
- 当无匹配或部分成交时，委托单的部分数据包括剩余未成交的数量会暂时保存到订单薄中，等待与后续的委托单匹配撮合。

# 连续竞价

连续竞价是一种交易机制，用于在市场开放期间持续进行证券或其他金融资产的买卖交易。在这个机制下，市场上的买家和卖家可以不断提交订单，并且交易将以市场上当前的最优价格成交。

[市场深度](./words_exchange.md#market-depth)。

连续竞价下的撮合引擎通常根据**价格优先**和**时间优先**原则，即时地将买方和卖方的订单进行撮合。

连续竞价提供了实时的价格发现机制，投资者可以根据市场上最新的成交价格和订单簿情况作出决策。

> 集合竞价（Closing Auction）是另一种交易机制，通常用于市场收盘时确定当日的收盘价。这个过程是在一个指定的时间段内进行的，允许市场上的买家和卖家提交他们的订单，并在收盘时以一个共同的价格撮合这些订单。
>
> 集合竞价通常在交易日结束前的最后一段时间内进行，这个时间段被称为集合竞价期间。
>
> 在集合竞价期间，市场上的买方和卖方都有机会提交他们的限价订单，以确定最终的收盘价。
>
> 在集合竞价结束时，撮合引擎会分析市场上所有提交的订单，找到一个价格，该价格上所有的买卖订单都能得到满足。这个价格被称为集合竞价的成交价格。
>
> 集合竞价通常适用于股票市场等金融市场，确保在收盘时形成一个有意义的、市场参与者普遍认可的收盘价。这种机制有助于避免在收盘时的剧烈价格波动，同时提供一个最终的成交价，供投资者参考。

# 委托单撮合引擎

满足成交条件，就能即时成交！

## 注意

同一个交易对的订单只能由**一个**撮合引擎**串行处理**！

如果可以由多个引擎并行处理的话，会产生问题：并行后同一时刻可能会产生多个成交价，无法确定以哪个成交价为准；并行后为了维护每个交易对统一的委托单账本，复杂度会较高且会影响性能，如果用采用数据库维护会降低撮合性能。

- 开启撮合

开启撮合的结果是同步返回的，因此没有异步的输出。

开启撮合涉及的逻辑：撮合引擎状态检查（**已开启撮合的交易对无法重复开启**！）、初始化 OrderBook、恢复未撮合完成的委托单。

## 撮合原则

撮合的两个原则：

1. 价格优先：买单，则价高者优先成交；卖单，则价低者优先成交
2. 时间优先：买卖方向相同和价格相同的委托单，先提交的委托单优先成交

`买入价 >= 卖出价` 才能撮合成交！`买入价 == 卖出价` 时，成交价就是买入/卖出价；`买入价 > 卖出价` 时，要参考前一笔成交价来确定最新成交价：

> 假设买入价为 BidPrice，卖出价为 AskPrice，前一成交价为 LastPrice，最新成交价为 LatestPrice

- 如果 LastPrice >= BidPrice，则 LatestPrice = BidPrice
- 如果 LastPrice <= AskPrice，则 LatestPrice = AskPrice
- 如果 BidPrice > LastPrice > AskPrice，则 LatestPrice = LastPrice

## 基于数据库VS基于内存

- 基于数据库的撮合引擎

优：有较好的持久性和数据管理特性；数据库方便监控、备份和恢复；可以很方便地查询。

缺：数据库读写的操作都是磁盘 I/O，比内存慢，系统延迟较高；随着交易量的增加，数据库的读写压力可能会导致性能下降，所以可伸缩性较差。

- 基于内存的撮合引擎

优：延迟低；高吞吐量，可以处理更高的交易量，适用于高频交易和大规模撮合需求；可以更容易的水平扩展，以适应不断增长的交易流量。

缺：数据丢失风险更高，需要额外的机制来确保数据的持久性；为了保障高可用性、故障恢复等，系统复杂性高。

## OrderBook(订单薄)

OrderBook 是撮合引擎中最核心的数据结构！每个交易对都需要维护一份 OrderBook，OrderBook 用于记录和管理买、卖方的待撮合委托单，因此每份 OrderBook 中都有两个队列：卖方订单、买方订单。两个队列都需要按照[撮合原则](#撮合原则)进行排序。

> OrderBook 还可以记录前一笔成交价、最新成交价

### 订单队列

买卖方订单队列仅排序方式不同，所以可以设计为统一的订单队列类型。

考虑到需要对订单进行排序，常见的对数据排序的基本数据结构有：数组、链表、树（二叉搜索树、红黑树等）、堆。

撮合引擎的排序原则至少包含了价格、时间两个纬度：

如果使用数组或链表的话，就需要使用二维数组或二维链表，由于撮合引擎中订单的主要操作是插入和删除，链表显然效率会更高，所以二维链表的话，第一维是按照价格排序的订单链表，每个订单链表是按时间排序的链表。

如果使用树形结构的话，要按照多个纬度进行排序，通常需要在每个节点上保存多个排序键。可以将多个纬度的排序键组合成一个复合键，每个节点存储这个复合键，排序时按复合键的顺序进行比较。

由于买卖方订单队列每次撮合时仅需取符合排序规则的第一笔委托单，而不关注其他委托单当下是否符合排序规则，所以可以使用堆来实现，因为堆虽然也维持着相对的顺序，但条件相对宽松，仅要求堆顶元素必须大于等于（或小于等于）其他元素。

因此可以使用堆来实现一个优先级队列作为订单队列的数据结构。

### 委托单

委托单所包含的基本属性：symbol(所属交易对)、orderId(委托单 ID)、side(交易方向（买入/卖出）)、side([交易类型（如限价/市价）](./words_exchange.md#订单类型))、amount、price、timestamp(委托单时间)。

### 成交记录

成交记录所包含的基本属性：makerId(挂单，本来挂在 OrderBook 中的订单)、takerId(吃单)、takerSide(吃单的买卖方向)、amount、price、timestamp(成交时间)。

# Reference

[交易系统](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5OTI1NDE0Mw==&action=getalbum&album_id=1626798248214495243)


