事务（transaction）是为了保证一组操作，要么全部成功，要么全部失败。

事务的四个特性（ACID）：

- Atomicity（原子性）：一个事务内的所有操作是一个整体，要么全部成功，要么全失败；
- Consistency（一致性）：事务提交或回滚后，数据库的完整性约束不能被破坏；
- Isolation（隔离性）：一个事务在提交之前，对其他事务都是不可见的；
- Durability（持久性）：事务提交之后对数据的修改是持久性的

# MySQL 事务

MySQL 的事务是在引擎层实现的。以下如不特殊说明均是指 InnoDB 存储引擎下的特性和实现！！

## 事务的隔离性

当数据库中有多个事务并发同时访问相同的数据时，可能会出现以下问题：

- 脏读（dirty read）
    - 事务 A 读取了已被 B 更新但还未提交的字段，之后，若 B 回滚，A 读取的内容就是无效的
- 不可重复读（non-repeatable read）
    - 事务 A 读取了一个字段，然后 B 修改/删除了该字段，之后，A 再次读取该字段，值就不同了
- 幻读（phantom read）
    - 事务 A 从表中查询符合条件的数据，第一次没有读到，然后 B 在该表中插入一些新的行，之后，如果 A 再次读取就读到了

为了解决这些问题，就有了"隔离级别"的概念。

SQL 标准的事务隔离级别：

- 读未提交（Read Uncommitted）：允许事务 B 看到事务 A 尚未提交变更
- 读已提交（Read Committed）：只允许事务 B 看到事务 A 已提交的变更
- 可重复读（Repeatable Read）：事务 B 执行过程中看到的数据总是与事务 B 启动时看到的一致，且事务 A 未提交的变更对事务 B 是不可见的
- 串行化（Serializable）：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

| 隔离级别（✓ 代表可以解决该问题） | 脏读  | 不可重复读 | 幻读  |
|-------------------|-----|-------|-----|
| 读未提交              | ×   | ×     | ×   |
| 读已提交              | ✓   | ×     | ×   |
| 可重复读              | ✓   | ✓     | ×   |
| 串行化               | ✓   | ✓     | ✓   |

MySQL 支持 4 种事务隔离级别，默认的事务隔离级别是 "Repeatable Read"，Oracle 默认 "Read Committed"。

| 事务 A        | 事务 B      |
|-------------|-----------|
| 启动事务，查询值为 1 | 启动事务      |
|             | 查询值为 1    |
|             | 将 1 修改为 2 |
| 查询得到值 v1    |           |
|             | 提交事务      |
| 查询得到值 v2    |           |
| 提交事务        |           |
| 查询得到值 v3    |           |

假设隔离级别是"读未提交"，则 `v1 = 2, v2 = 2, v3 = 2`；
假设隔离级别是"读已提交"，则 `v1 = 1, v2 = 2, v3 = 2`；
假设隔离级别是"可重复读"，则 `v1 = 1, v2 = 1, v3 = 2`；
假设隔离级别是"串行化"，则 `v1 = 1, v2 = 1, v3 = 2`。

## MVCC

MVCC(Multi-Version Concurrency Control，多版本并发控制)
通过数据行的多个版本管理来实现数据库的并发控制。其主要思想：保存数据的历史版本，然后通过对比版本号来决定某个版本的数据是否显示出来，读取数据时不需要加锁就可以保证事务的隔离效果。

### 几个基本概念

- 事务 ID(trx_id)：用于标识事务，是一个自增的序号，每个事务开始前就会申请一个
- 隐藏列：InnoDB 的叶子节点存储了数据页，数据页中保存了行记录，而在行记录中还有一些重要的隐藏字段
    - row trx_id，记录该行数据的当前版本是在那哪个事务中被修改的
    - roll_pointer，一个指向更早记录值的指针
- undo log：回滚日志，记录了事务开始前的状态，用于事务失败时回滚；还用于实现 MVCC
    - 上面的 roll_pointer 指向的其实就是 undo log 的记录
    - 由于 roll_pointer 的存在，数据表中的每一行记录都可能有多个版本，每个版本有自己的 row trx_id，而 undo log
      中同一行记录的多个版本通过指针形成了一个类似单向链表的结构

> 行记录的隐藏列中还有一个 row id，用来生成默认的聚集索引。如果创建数据表时没有指定聚集索引，InnoDB 就会用该字段创建聚集索引。

- 快照读：select 时会按照一定规则从版本链中选择一个合适的版本（不一定是最新值）读出来，就像一个快照
- 当前读：读的就是记录的最新值

### Read View 读视图

多个事务对同一个行记录进行更新会在 undo log 中产生多个历史快照，当前事务通过 Read View 并根据一定的规则来判断自己要读取哪个版本的行记录。

Read View 记录了当前事务开启时所有活跃（开启了事务但未提交）的事务列表，即下图中的视图数组。

![](../images/read-view.jpg)

图中的低水位 low_id = 视图数组中最小的事务 ID，高水位 high_id = 视图数组中最大的事务 ID + 1，活跃事务数组为 trx_list。

对于当前事务的启动瞬间而言，一个数据版本的 row trx_id 有以下几种可能：

1. row trx_id < low_id，说明这个行记录在那些活跃事务创建前就提交了，因此这个行记录的最新值对当前事务是可见的；
2. row trx_od > high_id，说明这个行记录是在这些活跃事务创建后才创建的，因此这个行记录的最新值对当前事务是不可见的；
3. low_id < row trx_id < high_id，还有两种情况
    1. row trx_id 在 trx_list 中，说明这个行记录是由尚未提交的事务生成的，因此这个行记录的最新值对当前事务不可见
    2. row trx_id 不在 trx_list 中，说明生成这个行记录的事务虽然不是最早开始的，但是结束的比 trx_list
       中的事务早，以至于当前事务开始时，它已经提交了，因此这个行记录的最新值对当前事务不可见

### 查询流程

1. 获取事务自己的 trx_id
2. 获取 Read View
3. 查询得到的数据，将 row trx_id 与 Read View 对比
4. 如果该数据的最新值对当前事务不可见，通过该数据的 roll_pointer 和 undo log 通过类似链表的遍历操作来获取历史快照
5. 返回符合规则的数据

通过这种方式，当事务开启后，无论事务什么时候查询，看到的数据结果都是一致的，所以称为**一致性读**。

### 更新流程

假设在 A 开启前，仅存在一个活跃事务（trx_id = 99），且 id=1 的这一行数据的 row trx_id = 90，value = 1。

| 事务 A                             | 事务 B                                | 事务 C                                              | id=1 的行记录                 |
|----------------------------------|-------------------------------------|---------------------------------------------------|---------------------------|
| `begin`，trx_id = 100             |                                     |                                                   | value=1，row trx_id = 90   |
|                                  | `begin`，trx_id = 101                |                                                   | value=1，row trx_id = 90   |
|                                  |                                     | `UPDATE table SET k=k+1 WHERE id=1`, trx_id = 102 | value=2, row trx_id = 102 |
|                                  | `UPDATE table SET k=k+1 where id=1` |                                                   | value=3, row trx_id = 101 |
|                                  | `SELECT k FROM table where id=1`    |                                                   |                           |
| `SELECT k from table WHERE id=1` |                                     |                                                   |                           |
| `commit`                         |                                     |                                                   |                           |
|                                  | `commit`                            |                                                   |                           |

注意，事务 C 先提交，生成了 row trx_id = 102 的版本，而事务 B 在 `UPDATE` 之前由于 B 的 trx_id =
101，其活跃数组为 [90, 100, 101]，而 id=1 的行记录 row trx_id = 102，所以最新的值 value=2 对事务 B 而言是不可见的，此时，如果
B 先 `SELECT` 的话，得到值是 value = 1。

但是！更新操作时会有一条特殊的规则：**更新数据都是先读后写的，而这个读，只能读当前最新的值，也就是"当前读"**。

因此，`UPDATE `的时候，先拿到 value=2 的值，然后再更新成 value=3 的版本。

而事务 B 中在 `UPDATE` 后面的那条 `SELECT` 语句查到当前最新版本为 value=3，且 row trx_id =
101，正好是自己的更新，可以直接使用，所以 `SELECT` 到的值为 3！！

除了 `UPDATE` 语句外，`SELECT` 语句如果加锁的话，也是当前读！如 `SELECT xxx FOR UPDATE` 也可以读到当前最新的值。

在 `SELECT` 的情况下，如果没有加 `FOR UPDATE` 的话就不会发生幻读，反之则会出现幻读的现象！！！

## 隔离级别的实现

- "读未提交"：直接返回记录上的最新值即可；
- "串行化"：直接使用加锁的方式来实现，性能很低。

而"读已提交"、"可重复读"两种隔离级别是借助视图(View) 实现的！！访问的时候以视图的逻辑结果为准。

- "可重复读" 的核心就是一致性读，会在事务启动时创建一个视图，整个事务存在期间都使用这一个视图
    - 而事务更新数据的时候，只能使用当前读，如果当前记录的行锁被其他事务占用的话，就需要进入锁等待了
- "读已提交"隔离界别下，每个 SQL 语句开始执行前都会创建一个新的视图

## 两种视图

在 MySQL 中有以下两种视图：

- view，用查询语句定义的虚拟表
- InnoDB 在实现 MVCC 时用的**一致性读视图（consistent read view）**，用于支持读已提交和可重复读的隔离级别的实现。
    - 一致性读视图没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。

# Redis 事务

Redis 提供了 `MULTI`、`EXEC` 两个命令，并通过三个步骤来实现事务：

1. Client 使用 `MULTI` 命令显式开启事务；
2. Client 把事务中要执行的一系列操作发送给 Redis 实例，Redis 实例会将这些命令暂存到一个命令队列中，而不会立刻执行；
3. Client 使用 `EXEC` 命令提交事务，让 Redis 实例执行第二步暂存的所有命令；当然 Client 也可以使用 `DISCARD`
   命令来取消事务，则暂存的所有命令会被清空。

```shell
$ MULTI
OK
$ SET Book_Name "Git Pro"
QUEUED 
$ SADD Program_Language "C++" "C#" "Jave" "Python" "Golang"
QUEUED
$ GET Book_Name
QUEUED
$ EXEC
1) OK
2) (integer) 4
3) "Git Pro"
```

Redis 并没有提供事务的回滚机制！

## 事务特性的支持

Redis 的事务无法完全保证事务的原子性！

- 事务操作入队的命令存在错误（如语法错误，命令不存在）
    - 入队时 Redis 会保存并记录该错误，这是还是可以正常提交命令的，而到了实际执行时 Redis
      就会拒绝执行所有提交的命令操作，返回事务失败的结果，这种情况是可以保证原子性的；
- 事务操作入队时命令和操作的数据类型不匹配，但 Redis 没有检查出来错误。
    - 实际执行时，Redis 会对这些错误的命令报错，但是正确的命令还是会执行，此时就**无法保证事务的原子性**了！
- Redis 开启了 AOF 日志，在执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败。
    - 此时只有部分事务操作被记录到了 AOF 日志中，使用 redis-check-aof 工具检查 AOF 日志文件，可以把未完成的事务操作从 AOF
      文件中去除。这样一来，我们使用 AOF 恢复实例后，事务操作不会再被执行，从而保证了原子性。

Redis 的事务可以保证事务的一致性。

Redis 的事务可以保证事务的隔离性。

- 并发操作在 `MULTI` 前执行，隔离性的保证是通过 WATCH 机制实现的，否则隔离性无法保证
    - 此时事务操作的命令暂存在命令队列中，如果有其他的并发操作，需要看事务是否使用了 WATCH 机制，如果使用了，则可以保证隔离性，未使用则无法保证
- 并发操作在 `MULTI` 后执行，隔离性可以保证
    - Redis 使用单线程执行命令，`EXEC` 执行后，Redis 会保证先把命令队列中的所有命令执行完。所以，在这种情况下，并发操作不会破坏事务的隔离性

Redis 的事务无法保证事务的持久性！

- 如果 Redis 没有使用 RDB 或 AOF，那么事务的持久化属性肯定得不到保证
- 如果 Redis 使用了 RDB 模式，那么，在一个事务执行后，而下一次的 RDB 快照还未执行前，如果发生了实例宕机，这种情况下，事务修改的数据也是不能保证持久化的
- 如果 Redis 采用了 AOF 模式，因为 AOF 模式的三种配置选项 no、everysec 和 always 都会存在数据丢失的情况，所以，事务的持久性还是得不到保证。

### WATCH 机制

WATCH 机制是由 `WATCH` 命令实现的。

会在在事务执行前，监控一个或多个键的值变化情况，当调用 `EXEC` 命令执行事务时，WATCH 机制会先检查监控的键是否被其它客户端修改了。

如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性也得到了保证。

```shell
$ WATCH balance wallet  # 监控 balance、wallet 两个 key
OK
$ MULTI
OK
$ DECRBY balance 20 # balance-20
QUEUED
$ INCRBY debt 20 # debt+20
QUEUED
$ EXEC # 如果在事务期间上面监控的任何一个 key 被其他 Client 修改了，放弃事务！返回失败
```

# 分布式事务

分布式事务，就是在分布式系统中运行的事务，由多个本地事务组合而成。

为了应用分布式环境中的复杂场景，分布式事务无法保证 ACID 中的强一致性(C)，于是出现了 BASE 理论，其关键点在于使用最终一致性代替了强一致性！

> 基本可用（Basically Available）：分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用；
> 软状态（Soft state）：允许系统存在中间状态，而该中间状态不会影响系统整体可用性；
> 分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。
> 最终一致性（Eventually consistent）：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。

分布式事务的实现：

- 基于 XA 协议的二阶段提交协议方法，强一致性，遵从 ACID 理论
- 三阶段提交协议方法，强一致性，遵从 ACID 理论
- 基于消息的最终一致性方法，最终一致性，遵从 BASE 理论

## 2PC

XA 是一个分布式事务协议，规定了事务管理器和资源管理器接口。事务管理器相当于协调者(Coordinator)，负责各个本地资源的提交和回滚；而资源管理器就是分布式事务的参与者(Cohort)，通常由数据库实现，比如 Oracle、DB2 等商业数据库都实现了 XA 接口。

基于 XA 协议的二阶段提交方法中，二阶段提交协议（Two-phase Commit Protocol，2PC），用于保证分布式系统中事务提交时的数据一致性。

2PC 的执行过程分为投票(Voting)、提交(Commit) 两个阶段。

1. 















