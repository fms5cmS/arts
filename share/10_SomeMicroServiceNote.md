
# 分布式系统的 NPC 挑战

分布式系统主要的挑战 NPC：Network Delay、Process Pause、Clock Drift

- Network Delay，网络延迟。虽然网络在多数情况下工作的还可以，虽然TCP保证传输顺序和不会丢失，但它无法消除网络延迟问题。
- Process Pause，进程暂停。有很多种原因可以导致进程暂停：比如编程语言中的 GC 会暂停所有正在运行的线程；再比如，我们有时会暂停云服务器，从而可以在不重启的情况下将云服务器从一台主机迁移到另一台主机。我们无法确定性预测进程暂停的时长，你以为持续几百毫秒已经很长了，但实际上持续数分钟之久进程暂停并不罕见。
- Clock Drift，时钟漂移。现实生活中我们通常认为时间是平稳流逝，单调递增的，但在计算机中不是。计算机使用时钟硬件计时，通常是石英钟，计时精度有限，同时受机器温度影响。为了在一定程度上同步网络上多个机器之间的时间，通常使用NTP协议将本地设备的时间与专门的时间服务器对齐，这样做的一个直接结果是设备的本地时间可能会突然向前或向后跳跃。

# API Gateway

API Gateway 可以屏蔽内部服务间的差异（开发语言、通信协议），

网关在微服务分层中位于负载均衡后面，是为了让网关无状态，这样就可以部署多台，而不会有单点问题。

网关的基本功能：反向路由（会将外部请求转换为内部具体的服务调用）、安全认证、限流熔断、日志监控

# 定时器

定时器 timer 的常见实现方式：

- 时间堆：常见使用小顶堆实现。

如果堆顶元素 > 当前时间，说明堆内所有元素都比当前时间大，即此时不必对时间堆进行处理。所以定时检查的时间复杂度位 O(1)。

如果堆顶元素 < 当前时间，说明此时已经由一批时间开始过期，进行正常的弹出和堆调整操作即可。每次堆调整的时间复杂度为 O(logN)。

Go 内置的定时器是使用时间堆实现的，不过不是二叉堆，而是四叉堆。

Go 1.10 将原本全局的四叉堆分割为 64 个更小的四叉堆，以减少访问全局四叉堆时必须加互斥锁的性能损耗。所有的计时器都以最小四叉堆的形式存储在 runtime.p 中，计时器由 P 的网络轮询器和调度器触发。

详见：[timer](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-timer/#63-计时器)

- 时间轮

可以想像成一个时钟，中心有秒针顺时针转动，每次转动到一个刻度时，就需要查看该刻度挂载的任务列表是否有已到期的任务。

结构类似哈希表，哈希算法为：触发时间 % 时间轮元素大小，而哈希冲突时，采用链表法来挂载冲突的定时器。

