Q1: 分布式锁怎么实现？

分布式锁需要满足几个条件：
1. 互斥性：在同一时间只会有一个实例能获取到锁
2. 避免死锁：这把锁在一段有限的时间之后，一定会被释放（正常释放或异常释放）
3. 锁要具备标识：不管要对锁做什么操作，首先要确认这把锁是我们自己的锁

互斥性主要通过 Redis 命令 `SETNX` 来实现；
为了避免异常情况无法主动释放锁导致的死锁，需要通过 Redis 命令 `EXPIRE` 对锁加上有效期，主动释放锁可以通过 Redis 命令 `DEL` 完成；
通过设置 value 值，在进行释放锁的操作时通过 Redis 命令 `GET` 获取 value 后来区分锁是否是自己持有。

`SETNX` 和 `EXPIRE` 是两个单独的命令，不具备原子性，如果 `SETNX` 执行完成后服务器宕机导致锁没有设置过期时间，就会发生死锁，可以使用 `SET key value NX PX expireTime`

释放锁时需要先 `GET` 再 `DEL`，可以通过 lua 脚本来保证两个操作的原子性。如果加锁操作有失败重试机制，那么在 `SET key value PX expireTime` 加锁之前需要先 `GET` 判断之前是否加锁成功，所以也需要使用 lua 脚本来保证多个命令的原子性！

Q2: 分布式锁的过期时间怎么设置？

根据自己的业务耗时来设置，如 999 线的时间。

Q3: 无论过期时间设置多长，极端情况下都会出现业务执行时间超过过期时间，怎么办？

可以考虑在锁未过期时，再一次延长过期时间（续约）。那么，过期时间不用设置很长，续约即可；实例崩溃了，则没有人再续约，过期后其他实例就可以拿到锁了。

> 如果根据 999 线设置过期时间，是否可以不考虑续约？

Q3.1: 间隔多久续约一次？续多长？

间隔跟网络、Redis 服务器的稳定性有关，可以由用户指定；续约时间可以使用原本的过期时间。

续约的间隔，应该综合考虑服务可用性。如果将分布式锁的过期时间设置为 10 秒，而且预期 2 秒内绝大概率续约成功，那么就可以考虑将续约间隔设置为 8 秒。

Q3.2: 续约失败的错误处理

如果是超时错误，可以再次尝试续约。但如果此时真的 Redis 服务器崩溃或者网络不通，那么会导致无限次尝试续约。超时时间用户指定。
其他错误直接返回

Q3.3: 续约失败了怎么中断后续业务？

无解，因为业务代码一旦执行，除非自己手动检测分布 式锁，并且手动中断，不然是没有办法的。

Q3.4: 是否设置续约次数上线？

仅提供手动续约？

Q4: 加锁重试

重试逻辑：
超时则直接加锁；
检查锁是否是自己之前加锁请求成功的，如果是，返回（考虑重置过期时间）；如果不是，根据重试策略来决定是否重试。

Q5: 分布式锁加锁失败有哪些原因？

超时、网络故障、Redis 服务器故障，以及锁被人持有着。

Q6: 补充

在非常高并发，并且热点集中的情况下，可以考虑结合 singleFlight 来进行优化。也就是说，本地所有的 goroutine 自己先竞争一把，胜利者再去抢全局的分布式锁。

根源上还是要尽量避免使用分布式锁。

Q7: Redis 集群的分布式锁

以上都是单点 Redis 下的分布式锁，如果是 Redis 集群，由于 master 节点宕机导致 master 节点变更，而如果变更前，从节点还没有同步原 master 的数据，那么当该从节点提升为 master 后会发现实例的锁没了。

Redlock 思路：部署多个主节点的 Redis 集群（没有从节点），多数节点加锁成功才认为加锁成功。
