
池化技术，其核心思想是空间换时间，期望使用预先创建好的对象来减少频繁创建对象的性能开销，同时还可以对对象进行统一的管理，降低了对象的使用的成本。要关注空间占用情况，避免出现空间过度使用出现内存泄露或者频繁 GC 等问题。

缺点：存储池子中的对象肯定需要消耗多余的内存，如果对象没有被频繁使用，就会造成内存上的浪费；池子中的对象需要在系统启动的时候就预先创建完成，这在一定程度上增加了系统启动时间。

如使用数据库连接池解决频繁创建连接带来的性能问题，使用线程池提升了并行查询数据库的性能。

## 数据库连接池

在做了一次全网的流量推广后，系统的访问速度开始变慢。分析程序的日志之后，发现系统慢的原因出现在和数据库的交互上。

数据库的调用方式是先获取数据库的连接，然后依靠这条连接从数据库中查询数据，最后关闭连接释放数据库资源。这种调用方式下，每次执行 SQL 都需要重新建立连接，所以频繁地建立数据库连接耗费时间长导致了访问慢的问题。

上述问题的解决方案：**使用连接池将数据库连接预先建立好**，这样在使用的时候就不需要频繁地创建连接了。

数据库连接池有两个最重要的配置：最小连接数和最大连接数。对于数据库连接池，一般在线上建议最小连接数控制在 10 左右，最大连接数控制在 20 ～ 30 左右即可。

```
如果当前连接数小于最小连接数，则创建新的连接处理数据库请求；
如果连接池中有空闲连接则复用空闲连接；
如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求；
如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用；
如果等待超过了这个设定时间则向用户抛出错误。
```

需要注意池子中连接的维护问题，一般出现问题的原因可能有：

- 数据库的域名对应的 IP 发生变更，池子的连接还是使用旧的 IP
    - 当旧的 IP 下的数据库服务关闭后，再使用这个连接查询就会发生错误
- MySQL 有个参数是“wait_timeout”，控制着当数据库连接闲置多长时间后，数据库会主动地关闭这条连接
    - 这个机制对于数据库使用方是无感知的，所以当我们使用这个被关闭的连接时就会发生错误。

那么，该如何保证池子中的连接一定可用呢？

- 启动一个线程来定期检测连接池中的连接是否可用
    - 如，使用连接发送`select 1`的命令给数据库看是否会抛出异常，如果抛出异常则将这个连接从连接池中移除，并且尝试关闭。
- 在获取到连接之后，先校验连接是否可用，如果可用才会执行 SQL 语句
    - 如，DBCP 连接池的 testOnBorrow 配置项用于控制是否开启这个验证
    - 这种方式在获取连接时会引入多余的开销，在线上系统中还是尽量不要开启，在测试服务上可以使用。

# Worker Pool

一个服务器上可以创建十几万甚至几十万的 goroutine，一个 goroutine 初始的栈大小为 2KB，在需要的时候可以扩展到 1GB，大量的 goroutine 是很消耗资源的，且大量的 goroutine 对于调度和 GC 的耗时还是会有影响的，因此，goroutine 并不是越多越好。可以创建一个 Worker Pool 来减少 goroutine 的使用。

如，实现 TCP 服务器，如果每个连接都都由一个独立的 goroutine 处理的话，大量连接时就会创建大量的 goroutine，这时，可以创建一个固定数量的 goroutine（worker），由这一组 worker 去处理连接。fasthttp 的 [WorkerPool](https://github.com/valyala/fasthttp/blob/9f11af296864153ee45341d3f2fe0f5178fd6210/workerpool.go)。

大部分的 Worker Pool 都通过 Channel 来缓存任务，有的是多个 Worker 共享同一个任务 Channel，有些是每个 Worker 都有独立的 Channel。

常用的 Go Worker Pool：[ants](https://github.com/panjf2000/ants)，[goworker](https://github.com/benmanns/goworker)、[tunny](https://github.com/Jeffail/tunny)。

在 [Handling 1 Million Requests per Minute with Go](http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/) 文章中利用 Go 的 channel 实现了 worker pool，来应对大并发请求，见 [worker](./examples/pool/millionRequestPerMinute/README.md)。

ants 包：

[基本使用](https://mp.weixin.qq.com/s/ysG0q9LIYgWHIoY_LK-W9A)

[源码分析](https://mp.weixin.qq.com/s/a84T6Hpbrhop7vQA01N1Bg)

如果使用线程池请一定记住不要使用无界队列（即没有设置固定大小的队列）。大量的任务堆积会占用大量的内存空间，一旦内存空间被占满就会频繁地触发 Full GC，造成服务不可用

# sync.Pool

sync.Pool 用于保存一组可独立访问的**临时**对象，可以创建池化的对象，但是，它池化的对象可能会无通知地被 GC 回收掉，这对于数据库等长连接场景是不合适的！！

> sync.Pool 本身是线程安全的，多个 goroutines 可以并发地调用它的方法存取对象；
>
> sync.Pool 不可在使用后再复制使用。

Pool 仅提供了三个对外的方法：

- `New` 该方法包含在 Pool 结构体中作为一个字段，当调用 `Get()` 从池中获取元素但没有空闲元素返回时会调用 `New()` 来创建新的元素。
    - 建议在创建 Pool 对象时设置该字段的值
- `Get()` 从池中取走一个元素，当没有设置 New 字段或池中没有空闲元素时，返回值为 nil，因此使用时可能需要进行判断
- `Put()` 将元素放入池中，如果放入一个 nil，则 Pool 会忽略这个值

保存和复用临时对象，减少内存分配，主要使用场景：
- 进程中的 inuse_objects 数过多，内存占用越来越高（监控图上进程 RSS 占用过高）
- 进程中的 inuse_objects 数过多，gc mark（需要遍历所有存活的对象） 消耗大量 CPU

[示例](../libs/builtin_sync/pool_test.go)

