# 遍历

- 前序（递归+非递归实现）：144
- 中序（递归+非递归实现）：94
- 后序（递归+非递归实现）：145

递归方法，只要实现了一种遍历方式，其他两种只要修改一下节点顺序就好了；

迭代方法，由于这三种遍历方式都属于深度优先遍历，可以借用栈实现：
- 前序遍历的顺序是中左右，先访问中间节点，要处理的也是中间节点；
- 中序遍历的顺序是左中右，先访问二叉树根节点，然后层层向下访问，直到访问到树最左边的节点，再开始处理该节点，访问顺序和处理顺序不一致！
- 后序遍历的顺序是左右中，可以先得到中右左，然后反转。

由于遍历节点的顺序和节点入栈顺序不一致，所以不易写出统一风格的代码。要写出统一风格的代码，见：[二叉树的统一迭代法](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.md) 但不太好理解！

- 层序遍历（非递归实现）：
    - 102, 107, 199, 637, 429, 515, 116, 117, 104, 111
    - 662

- **二叉树的后续遍历就是天然的回溯！**
    - 236

**前中后序遍历都属于深度优先遍历，层序遍历则是广度优先遍历**。广度优先遍历的意义在于可以更快地找到查询地元素。主要用于搜索策略上，而不是这里的遍历上。常用于算法设计中的最短路径问题。

深度优先算法(Depth-First-Search)用的是回溯思想，这种思想解决问题的过程适合用递归(借助栈)实现。

广度优先搜索(Breadth-First-Search)是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。通常使用队列实现。

# 深度&高度

- 如果要求**深度**，可以从上往下查找，所以需要的是**前序遍历**；
- 如果要求**高度**，就要从下往上查找，所以需要的是**后续遍历**。

见 104、559、111、110。

# 构造二叉树

- 106：根据中序和后序遍历构造二叉树
- 105：根据前序和中序遍历构造二叉树
- 654：构造最大二叉树（具体含义见题目）
- 108：有序数组构造平衡二叉树搜索树

前序和后序遍历时无法唯一确定一棵二叉树的！因为没有中序遍历就无法区分左右部分。

数组构造二叉树：本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间。

构造二叉树的时候尽量不要重新定义左右区间数组，而是用下标来操作原数组。

有序数组构造成的二叉树，一定是平衡的，因为大家默认都是从数组中间位置取值作为节点元素，一般不会随机取。

# 二叉搜索树树求最值、差值等

利用中序遍历有序的特征，可以将相关的题目想成对有序数组的处理

- 530：求最小差值
- 501：求众数（普通二叉树需要借助 map 统计节点值的频率，然后对频率排序）
- 538：转为累加树

# 递归函数的返回值

递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

1. 如果需要搜索整颗二叉树且不用处理递归返回值，递归函数就不要返回值。（113）
2. 如果需要搜索整颗二叉树且需要处理递归返回值，递归函数就需要返回值。（236）
3. 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（112）

# 树的一些操作

- 226：翻转二叉树
