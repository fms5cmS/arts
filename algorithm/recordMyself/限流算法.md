
固定窗口算法、滑动窗口算法、漏桶算法、令牌桶算法

# 固定窗口算法

go-zero 的 PeriodLimit 使用了 Redis 的过期时间来模拟固定时间窗口。

https://mp.weixin.qq.com/s/s8T1430LS-l3ks9cL7sZyw

# LeakyBucket 漏桶算法

将请求先放到一个**容量固定的桶**中排队，然后按照**固定的速率**来处理请求，而请求则是**以任意速率进入桶**中，当**桶满了的话，新的请求会被丢弃**。

漏桶以固定速率处理请求，可以看作是以固定速率生产 token，而请求拿到 token 则进行处理，拿不到则丢弃请求。

Golang 的第三方库实现：[ratelimit](https://github.com/uber-go/ratelimit) 是一个阻塞的漏桶算法实现，如果拿不到 token 的话，请求会阻塞住，直到拿到 token。

- 创建限流器：
  - `ratelimit.New(rate int, opts ...Option)` 创建一个 atomicLimiter 限流器实现
  - `ratelimit.NewUnlimited()` 不做限流
- 处理请求的固定速率：`perRequest := config.per / time.Duration(rate)`
  - config.per 为时间窗口，默认为 1s，可通过 `perOption` 选项设置
  - rate 为时间窗口内的请求数，即桶的容量，`ratelimit.New(100)` 的入参

```go
type state struct {
	last     time.Time      // 最新请求到来的当前时间
	sleepFor time.Duration  // 到下一次请求间的休眠时间
}

type atomicLimiter struct {
	state unsafe.Pointer
	padding [56]byte 

	perRequest time.Duration
	maxSlack   time.Duration
	clock      Clock
}
```

- 生成 token，每次实际操作之前都需要调用 `Take()`，在可以进行操作之前 `Take()` 会一直阻塞！
  - 获取当前时间 now、之前的限流器状态
  - 如果是第一次请求，更新限流器状态，返回
  - 不是第一次请求：
    - 计算下一次请求的休眠时间 = 上一次请求的休眠时间 + (perRequest - 当前和上一次请求的时间差)

time/rate/limiter 是一个令牌桶的实现



传统限流方式的缺陷：

- 粗粒度，无法为不同用户、不同场景设置不同的限流
- 单队列，共享限流窗口/桶，一个 bad 用户可能会导致整个系统堵塞，其他正常用户的请求无法被及时处理
- 不公平，正常用户的请求被排队到队尾，无法及时处理而饿死
- 无优先级，重要的系统指令一并被限流，系统故障难以恢复