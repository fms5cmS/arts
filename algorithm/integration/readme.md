# LRU(Least Recently Used)最近最少使用

**按时间顺序从最近到最晚对所有元素排序！！**

- 插入：每次新的元素都按**时间顺序**放在最前面
  - 如果 cache 未满，向 cache 中插入元素
  - 如果 cache 已满，还需要将 cache 中最早的元素删除
- 删除：删除 cache 中最早的元素
- 查找：每次只能查找到最近的元素

如果以链表的形式来看的话，**LRU 更新和插入都发生在链表首，删除都发生在链表尾**。

- 散列表+双向链表

LRU 要求查询尽量高效，O(1) 的查询时间复杂度，所以需要使用散列表 map 来优化；而为了修改、删除操作也尽量在 O(1) 内完成，可以采用双向链表！

cache 中的每个元素都保存在双向链表的节点中，同时，为了快速查找，也会在 map 中记录每个元素对应的双向链表节点地址。

[leetcode 代码实现](146_lru_test.go)

Q：如何实现一个高并发且线程安全的 LRU 呢？

要想做到高并发，需要考虑 2 点：
1. 内存分配与回收 GC 一定要快，最好是 Zero GC 开销
2. 执行操作耗时最少

> 高并发，瞬间的 TPS 可能会很大，所以要最快的分配内存，开辟新的内存空间。垃圾回收也不能慢，否则内存会暴涨。

在高并发的场景中，一定会保证线程安全。这里就需要用到锁。最简单的选用读写锁。但是在 Put 操作中，写锁会阻碍读操作，导致并发量下降，可以采用分段锁，让写锁尽可能少的阻碍读操作。

# LFU(Least Frequently Used)最少使用

**按时间从最近到最晚对所有元素顺序排序！！**

cache 中的每个元素还会有一个访问计数器来记录每个元素的访问次数。每种操作类似于 LRU，

，不过有个特殊的地方：如果要淘汰的访问次数对应了多个元素，那么仅淘汰最靠近尾部（即最早）的元素。

如果以链表的形式来看的话，**LFU 更新和插入可以发生在链表中任意位置，删除都发生在表尾。**

Q：如何按频次排序？

如果考虑排序算法的话，那就错了！回看 LFU 算法的工作原理，可以看出，它**只关注最小频次**！！其他频次的顺序并不关心，所以其实不需要按频次排序。

- 散列表+双向链表

1. 使用一个 min 变量保存最小频次，淘汰时读取这个最小值能找到要删除的结点
2. 相同频次按照先后顺序排列，依然使用双向链表实现
3. 相同频次对应一个双向链表，可能有多个相同频次，所以可能有多个双向链表
4. 用一个 map 维护访问频次和双向链表的对应关系

[leetcode 代码实现](460_lfu_test.go)


