package dpRela

func minCostClimbingStairs(cost []int) int {
	// 1. dp 数组，dp[i] 代表到达第 i 个台阶所花费的最小体力为 dp[i]
	dp := make([]int, len(cost))
	// 3. dp 数组初始化，从递推公式可以看出，dp[i] 是由 dp[i-1]、dp[i-2] 推导得出，所以只初始化 dp[0]、dp[1] 即可
	for i := 0; i < len(cost) && i < 2; i++ {
		dp[i] = cost[i]
	}
	// 4. 遍历，台阶从前往后遍历
	for i := 2; i < len(cost); i++ {
		// 2. 递推公式，注意这里需要加爬上 i 台阶时花费的体力值 cost[i]
		dp[i] = minOf2Int(dp[i-1], dp[i-2]) + cost[i]
	}
	return minOf2Int(dp[len(cost)-1], dp[len(cost)-2])
}

// 题目：
// 注意：最后一个台阶并不是楼顶！初始阶梯可以从 0 或 1 开始
// 示例一：cost = [10, 15, 20]，输出 15
//       选择下标为 1 的元素作为初始阶梯，支付离开 1 阶的体力 15，跨两（！）步达到楼顶
// 示例二：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]，输出 6
//       选择下标为 0 的元素作为初始阶梯
//       1. 支付离开 0 阶的体力 1，跨两步到达 2 阶
//       2. 支付离开 2 阶的体力 1，跨两步到达 4 阶
//       3. 支付离开 4 阶的体力 1，跨两步到达 6 阶
//       4. 支付离开 6 阶的体力 1，跨一步到达 7 阶
//       5. 支付离开 7 阶的体力 1，跨两步到达 9 阶
//       6. 支付离开 9 阶的体力 1，跨一步到达楼顶
//                   总体力为 6
