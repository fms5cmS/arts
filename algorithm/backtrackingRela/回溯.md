回溯的处理思想，类似枚举搜索。枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，会将问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候(不符合期望的解)，就回退到上一个岔路口，另选一种走法继续走。

大部分情况下，回溯算法都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。**回溯算法非常适合用递归来实现**，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用**剪枝**，我们并不需要穷举搜索所有的情况，从而提高搜索效率。

回溯法一般可以用于解决以下问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
  - 77, 216, 17, 39, 40
- 切割问题：一个字符串按一定规则有几种切割方式
  - 93, 131
  - 切割问题类似于组合问题：
    - 组合问题：选取一个 a 之后，在 bcdef 中再去选取第二个，选取 b 之后在 cdef 中在选组第三个.....
    - 切割问题：切割一个 a 之后，在 bcdef 中再去切割第二段，切割 b 之后在 cdef 中在切割第三段.....
- 子集问题：一个N个数的集合里有多少符合条件的子集
  - 78, 90, 491
- 排列问题：N个数按一定规则全排列，有几种排列方式
  - 46, 47
- 棋盘问题：N皇后，解数独等等
  - 51, 37

包含去重的题目：40, 90, 491, 47

**所有回溯法的问题都可以抽象为 N 叉树形结构的遍历！**，类似于深度优先遍历。摸板：

for 循环用来遍历（子）集合；递归函数用来操作（子）集合。

```go
func backtracking(参数) {
  if (终止条件) {
    存放结果;
    return;
  }
  
  for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
  }
}
```